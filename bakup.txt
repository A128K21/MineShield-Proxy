use log::{error, info};
use std::collections::HashMap;
use std::io::{self, BufRead, BufReader, Read, Write};
use std::net::{IpAddr, TcpListener, TcpStream};
use std::sync::{Arc, RwLock};
use threadpool::ThreadPool;
use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
use env_logger::{Builder, Env};
use std::io::Write as IoWrite;

const PROXY_V2_SIG: [u8; 12] = [0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A];

fn main() -> io::Result<()> {
    // Initialize the logger with a custom format
    Builder::from_env(Env::default().default_filter_or("info"))
        .format(|buf, record| {
            writeln!(buf, "{}: {}", record.level(), record.args())
        })
        .init();

    let listen_addr = "0.0.0.0:25565"; // Default Minecraft port
    let num_threads = 4; // Adjust based on expected load
    let mappings = Arc::new(RwLock::new(HashMap::new()));
    let pool = ThreadPool::new(num_threads);
    let listener = TcpListener::bind(listen_addr)?;
    info!("Listening on {}", listen_addr);

    // Example usage: add 5 domains and remove 2 of them
    add_domain(&mappings, "test.mineshield.xyz".to_string(), "127.0.0.1:25577".to_string());
    add_domain(&mappings, "example1.com".to_string(), "128.0.0.1:24445".to_string());
    add_domain(&mappings, "example2.com".to_string(), "127.0.0.1:24446".to_string());
    add_domain(&mappings, "example3.com".to_string(), "127.0.0.1:24447".to_string());
    add_domain(&mappings, "example4.com".to_string(), "127.0.0.1:24448".to_string());
    remove_domain(&mappings, "example0.com");
    remove_domain(&mappings, "example1.com");

    for stream in listener.incoming() {
        match stream {
            Ok(stream) => {
                let mappings = mappings.clone();
                pool.execute(move || {
                    if let Err(e) = handle_connection(stream, &mappings) {
                        error!("Failed to handle connection: {}", e);
                    }
                });
            }
            Err(e) => {
                error!("Failed to accept connection: {}", e);
            }
        }
    }

    Ok(())
}

fn handle_connection(mut stream: TcpStream, mappings: &Arc<RwLock<HashMap<String, String>>>) -> io::Result<()> {
    let header = read_and_convert_proxy_protocol(&mut stream)?;
    let server_address = parse_minecraft_handshake(&mut stream)?;
    let target_address = resolve_target_address(&server_address, mappings)?;
    let packet_info = read_packet_info(&mut stream)?;

    check_connection_state(packet_info)?;

    let mut target_stream = TcpStream::connect(target_address.clone())?;
    info!("Redirecting connection for {} to {}", server_address, target_address);

    send_proxy_protocol(&mut target_stream, &header)?;

    transfer_data(&mut stream, &mut target_stream)?;
    transfer_data(&mut target_stream, &mut stream)?;

    Ok(())
}

fn resolve_target_address(server_address: &str, mappings: &Arc<RwLock<HashMap<String, String>>>) -> io::Result<String> {
    let mappings = mappings.read().unwrap();
    mappings.get(server_address).ok_or_else(|| {
        io::Error::new(io::ErrorKind::NotFound, "Hostname not found in mappings")
    }).map(|s| s.to_string())
}

fn read_packet_info(stream: &mut TcpStream) -> io::Result<(i32, i32)> {
    let packet_length = read_var_int(stream)?;
    let packet_id = read_var_int(stream)?;
    Ok((packet_length, packet_id))
}

fn check_connection_state(packet_info: (i32, i32)) -> io::Result<()> {
    match packet_info.1 {
        0x00 => {
            if packet_info.0 == 1 {
                info!("New connection: ping request");
            } else {
                info!("New connection: join request");
            }
        }
        _ => {
            return Err(io::Error::new(io::ErrorKind::InvalidData, "Unexpected packet ID after handshake"));
        }
    }
    Ok(())
}

fn read_and_convert_proxy_protocol(stream: &mut TcpStream) -> io::Result<Vec<u8>> {
    // Peek the first 16 bytes to determine the protocol version
    let mut peek_buf = [0u8; 16];
    stream.peek(&mut peek_buf)?;

    if &peek_buf[0..12] == PROXY_V2_SIG {
        // Proxy Protocol v2
        let mut header = vec![0u8; 16];
        stream.read_exact(&mut header)?;
        let length = (&header[14..16]).read_u16::<BigEndian>()?;
        let mut address = vec![0u8; length as usize];
        stream.read_exact(&mut address)?;
        header.extend(address);
        info!("Received Proxy Protocol v2 header: {:?}", header);
        Ok(header)
    } else {
        // Proxy Protocol v1
        let mut reader = BufReader::new(stream);
        let mut line = String::new();
        reader.read_line(&mut line)?;
        let parts: Vec<&str> = line.trim().split_whitespace().collect();

        if parts.len() < 6 || parts[0] != "PROXY" {
            return Err(io::Error::new(io::ErrorKind::InvalidData, "Invalid Proxy Protocol v1 header"));
        }

        let family = match parts[1] {
            "TCP4" => 0x11, // AF_INET | SOCK_STREAM
            "TCP6" => 0x21, // AF_INET6 | SOCK_STREAM
            _ => return Err(io::Error::new(io::ErrorKind::InvalidData, "Unsupported address family")),
        };

        let src_addr = parts[2].parse::<IpAddr>().map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e.to_string()))?;
        let dst_addr = parts[3].parse::<IpAddr>().map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e.to_string()))?;
        let src_port = parts[4].parse::<u16>().map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e.to_string()))?;
        let dst_port = parts[5].parse::<u16>().map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e.to_string()))?;

        info!("Parsed Proxy Protocol v1 header - Family: {}, Source Address: {}, Destination Address: {}, Source Port: {}, Destination Port: {}", parts[1], src_addr, dst_addr, src_port, dst_port);

        let mut header = vec![];
        header.extend_from_slice(&PROXY_V2_SIG);
        header.push(0x21); // Version 2 and command: LOCAL (proxy)
        header.push(family);

        let mut addr_info = vec![];
        match (src_addr, dst_addr) {
            (IpAddr::V4(src), IpAddr::V4(dst)) => {
                addr_info.extend_from_slice(&src.octets());
                addr_info.extend_from_slice(&dst.octets());
            }
            (IpAddr::V6(src), IpAddr::V6(dst)) => {
                addr_info.extend_from_slice(&src.octets());
                addr_info.extend_from_slice(&dst.octets());
            }
            _ => return Err(io::Error::new(io::ErrorKind::InvalidData, "Mismatched IP address families")),
        }

        addr_info.write_u16::<BigEndian>(src_port)?;
        addr_info.write_u16::<BigEndian>(dst_port)?;

        header.write_u16::<BigEndian>(addr_info.len() as u16)?;
        header.extend_from_slice(&addr_info);

        info!("Converted Proxy Protocol v1 to v2 header: {:?}", header);
        Ok(header)
    }
}

fn send_proxy_protocol(stream: &mut TcpStream, header: &[u8]) -> io::Result<()> {
    info!("Sending Proxy Protocol v2 header: {:?}", header);
    stream.write_all(header)?;
    stream.flush()?;
    Ok(())
}

fn parse_minecraft_handshake(stream: &mut TcpStream) -> io::Result<String> {
    let _packet_length = read_var_int(stream)?;
    let packet_id = read_var_int(stream)?;

    if packet_id != 0x00 {
        return Err(io::Error::new(io::ErrorKind::InvalidData, "Unexpected packet ID"));
    }

    let _protocol_version = read_var_int(stream)?;
    let server_address = read_string(stream)?;
    let _server_port = stream.read_u16::<BigEndian>()?;
    let _next_state = read_var_int(stream)?;
    Ok(server_address)
}

fn read_var_int(stream: &mut TcpStream) -> io::Result<i32> {
    let mut num_read = 0;
    let mut result = 0;

    loop {
        let read = stream.read_u8()?;
        let value = (read & 0b01111111) as i32;
        result |= value << (7 * num_read);
        num_read += 1;

        if num_read > 5 {
            return Err(io::Error::new(io::ErrorKind::InvalidData, "VarInt is too big"));
        }

        if (read & 0b10000000) == 0 {
            break;
        }
    }

    Ok(result)
}

fn read_string(stream: &mut TcpStream) -> io::Result<String> {
    let length = read_var_int(stream)? as usize;
    let mut buffer = vec![0; length];
    stream.read_exact(&mut buffer)?;
    String::from_utf8(buffer).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e.to_string()))
}

fn transfer_data(reader: &mut TcpStream, writer: &mut TcpStream) -> io::Result<()> {
    let mut buffer = [0u8; 4096];

    while let Ok(size) = reader.read(&mut buffer) {
        if size == 0 {
            break;
        }

        writer.write_all(&buffer[..size])?;
        writer.flush()?;
    }

    Ok(())
}

// Functions to add and remove domains dynamically
fn add_domain(mappings: &Arc<RwLock<HashMap<String, String>>>, domain: String, address: String) {
    let mut mappings = mappings.write().unwrap();
    mappings.insert(domain.clone(), address.clone());
    info!("Added domain: {} with address: {}", domain, address);
}

fn remove_domain(mappings: &Arc<RwLock<HashMap<String, String>>>, domain: &str) {
    let mut mappings = mappings.write().unwrap();
    if mappings.remove(domain).is_some() {
        info!("Removed domain: {}", domain);
    } else {
        info!("Domain not found: {}", domain);
    }
}
